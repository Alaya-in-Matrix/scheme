(define nil (quote ()))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
            (cons (car sequence)
                  (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
;==================================定义区==================================
(define (memq? item x)
  (cond ((null? x) #f)
        ((eq? item (car x)) x)
        (else (memq? item (cdr x)))))
;2.54 2013/2/24 15:44:52
(define (equal list1 list2)
  (cond ((not (or (pair? list1) (pair? list2)))
          (eq? list1 list2))            
        ((and (pair? list1) (pair? list2))
          (and (equal (car list1) (car list2))
               (equal (cdr list1) (cdr list2))))
        (else #f)))       

;================2.58 b) 2013/2/27 22:03:54=====================================
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
          (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        (else
          (error "unknown expression type -- DERIV" exp)))) 
(define (variable? x)
  (symbol? x))     
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (=number? exp num)
  (and (number? exp ) (= exp num)))
(define (sum? x)
  (memq? (quote +) x))
(define (product? x) ;?г???????
  (and (pair? x)
       (not (memq? (quote +) x))
       (memq? (quote *) x)))  
(define (make-sum a1 a2)
  (cond ((=number?  a1  0) a2)
        ((=number?  a2  0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 (quote +) a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 (quote *) m2)))) 
(define (operand1 exp op)
  (define (operand expr oper)
    (if (or (null? expr) (eq? oper  (car expr)))
      nil
      (cons (car expr) (operand (cdr expr) oper))))
  (let ((temp (operand exp op)))
    (if (> (length temp) 1) temp (car temp))))
(define (addend x)
  (operand1 x (quote +)))
(define (multiplier p)
  (operand1 p (quote *)))             
(define (operand2 exp op)
  (let ((temp (cdr (memq? op exp))))
    (if (> (length temp) 1) temp (car temp))))
(define (augend x)
  (operand2 x (quote +)))
(define (multiplicand p)
  (operand2 p (quote *)))

;=======================????????????==============================  
#|
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))
(define (adjoin-set x set)
  (if (element-of-set? x set)
    set
    (cons x set)))
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) nil)
        ((element-of-set? (car set1) set2)
          (cons (car set1)
                (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
;2.59     2013/2/28 12:56:25
(define (union-set set1 set2)
  (cond ((null? set2) set1)
        ((element-of-set? (car set2) set1)
         (union-set set1 (cdr set2)))
        (else (union-set (cons (car set2) set1) (cdr set2)))))
;2.60     2013/2/28 13:07:11
;略
|#
;======================集合作为排序的表================================
#|
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((= x (car set) #t))
        (else (element-of-set? x (cdr set)))))
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
    nil
    (let ((x1 (car set1)) (x2 (car set2)))
      (cond ((= x1 x2)
             (cons x1 (intersection-set (cdr set1) (cdr set2))))
            ((< x1 x2)
             (intersection-set (cdr set1) set2))
            ((< x2 x1)
             (intersection-set set1 (cdr set2)))))))
;2.61 2013/2/28 19:33:20             
(define (adjoin-set element set)
    (cond ((null? set) (list element))
          ((= element (car set)) set);无重复
          ((< element (car set)) (cons element set))
          (else (cons (car set) (adjoin-set element (cdr set))))))
;2.62   2013/2/28 19:59:10
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else
          (let ((x1 (car set1)) (x2 (car set2)))
            (cond ((= x1 x2)
                    (union-set set1 (cdr set2)))
                  ((< x1 x2) 
                    (cons x1 (union-set (cdr set1) set2)))
                  ((> x1 x2)
                    (cons x2 (union-set (cdr set2) set1))))))))
|#                    
;================================集合作为二叉树================================================                    
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((= x (entry set)) #t)
        ((< x (entry set)) 
          (element-of-set? x (left-branch set)))
        ((> x (entry set))
          (element-of-set? x (right-branch set)))))
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x nil nil))
        ((= x (entry set)) set)
        ((< x (entry set)) 
          (make-tree (entry set)
                     (adjoin-set x (left-branch set))
                     (right-branch set)))
        ((> x (entry set))
          (make-tree (entry set)
                     (left-branch set)
                     (adjoin-set x (right-branch set))))))
;2.63   
;n and log(n)?                     
(define (tree->list1 tree)
  (if (null? tree)
    nil
    (append (tree->list1 (left-branch tree))
            (cons (entry tree)
                  (tree->list1 (right-branch tree))))))
(define (tree->list2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree) 
                            (copy-to-list (right-branch tree)
                                           result-list)))))
  (copy-to-list tree nil))
;2.64
(define (list->tree given_list)
  (define (middle given)
    (let ((len (length given)))
      (cond ((odd? len) (list-ref given (quotient len 2)))
            (else (list-ref given (- (/ len 2) 1))))))
  (define (left-side given)
    (filter (lambda (x) (< x (middle given))) given))
  (define (right-side given)
    (filter (lambda (x) (> x (middle given))) given))
  (if (null? given_list)
      nil
      (make-tree (middle given_list)
                 (list->tree (left-side given_list))
                 (list->tree (right-side given_list)))))
;2.64
(define (list->tree2 elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons nil elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree)
                      remaining-elts))))))))      
;2.65 2013/3/1 19:16:58
(define (intersection-set set1 set2)
	(define (list-intersection-set set1 set2)
  	(if (or (null? set1) (null? set2))
    	nil
    	(let ((x1 (car set1)) (x2 (car set2)))
      	(cond ((= x1 x2)
             		(cons x1 (list-intersection-set (cdr set1) (cdr set2))))
            	((< x1 x2)
             		(list-intersection-set (cdr set1) set2))
            	((< x2 x1)
             		(list-intersection-set set1 (cdr set2)))))))	
  (let ((SET1 (tree->list1 set1))
        (SET2 (tree->list1 set2)))
		(list->tree (list-intersection-set SET1 SET2))))
(define (union-set set1 set2)
	(define (union set1 set2)
  	(cond ((null? set1) set2)
        	((null? set2) set1)
        	(else
          	(let ((x1 (car set1)) (x2 (car set2)))
            	(cond ((= x1 x2)
                    	(union set1 (cdr set2)))
                  	((< x1 x2) 
                    	(cons x1 (union (cdr set1) set2)))
                  	((> x1 x2)
                    	(cons x2 (union (cdr set2) set1))))))))
	(let ((SET1 (tree->list1 set1))
				(SET2 (tree->list1 set2)))
		(list->tree (union SET1 SET2))))
;===========================Huffman树的表示=================================		
(define (make-leaf symbol weight)
  (list (quote leaf) symbol weight))
(define (leaf? object)
  (eq? (car object) (quote leaf)))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
(define (make-code-tree left right)
  (list left
        right
        (append (symbol left) (symbol right))
        (+ (weight left) (weight right))))
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbol tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
(define (decode bits tree)
  (define (decode-1 bits current-branch);?is it OK to use 'bits' as a parameter of this function?
    (if (null? bits)
        nil
        (let ((next-branch
                (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0)  (left-branch branch))
        ((= bit 1)  (right-branch branch))
        (else (error "bad bit --CHOOSE BRANCH" bit))))
;2.67   2013/3/2 10:07:02
(define sample-tree (make-code-tree (make-leaf (quote A) 4)
                               (make-code-tree
                                  (make-leaf (quote B) 2)
                                  (make-code-tree (make-leaf (quote D) 1)
                                                  (make-leaf (quote C) 1)))))
(define sample-message (quote (0 1 1 0 0  1 0 1 0 1 1 1 0)))
;(A D A B B C A)
                                                  
;2.68   2013/3/2 10:58:44                
(define (encode message tree)
  (if (null? message)
      nil
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
(define (encode-symbol sym tree) ;似乎是n*log(n)的复杂度......
  (let ((SYMBOL (symbol tree)))
    (if (not (memq? sym SYMBOL))
        (error "error:what the fuck")
        (if (equal SYMBOL (list sym))
            nil
            (cond ((memq? sym (symbol (left-branch tree)))
                    (cons 0 (encode-symbol sym (left-branch tree))))
                  ((memq? sym (symbol (right-branch tree)))
                    (cons 1 (encode-symbol sym (right-branch tree)))))))))
;2.69   2013/3/2 14:05:00
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
      nil
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)
                               (cadr pair))
                    (make-leaf-set (cdr pairs))))))
(define (generate-huffman-tree pairs)
  (car (successive-merge (make-leaf-set pairs))))
(define (successive-merge set)
  (if (eq? nil (cdr set))
      set
      (successive-merge (adjoin-set (make-code-tree (car set)
                                                    (cadr set))
                                    (cddr set)))))
;2.70   2013/3/2 14:52:55                                       
(define pairs (quote ((A 2) (NA 16)
                      (BOOM 1) (SHA 3)
                      (GET 2) (YIP 9)
                      (JOB 2) (WAH 2))))
(define song (quote (GET A JOB
                     SHA NA NA NA NA NA NA NA NA
                     GET A JOB
                     SHA NA NA NA NA NA NA NA NA
                     WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP
                     SHA BOOM)))    
 #|(quote (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0 1 1 1 
 1 1 1 1 0 0 1 1 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 
 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 0 1 1 1 1 0 0))|#
 (define pairs (quote ((I1 0.45) (I2 0.30) (I3 0.15) (I4 0.05) (I5 0.03) (I6 0.01) (I7 0.01))))
 (define instruction (quote (I1 I2 I3 I4 I5 I6 I7 I8)))
